<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¾·å·æ‰‘å…‹ç­¹ç è®¡ç®—å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        [v-cloak] { display: none; }
        .btn-action { transition: all 0.15s ease; }
        .btn-action:active { transform: scale(0.95); }
        .player-card { transition: all 0.3s ease; }
        .player-card.folded { opacity: 0.5; }
        .player-card.all-in { border-color: #f59e0b !important; }
    </style>
</head>
<body class="bg-gradient-to-br from-green-900 via-green-800 to-green-900 min-h-screen">
    <div id="app" v-cloak class="container mx-auto px-4 py-6 max-w-lg">
        <!-- æˆ¿é—´é€‰æ‹©ç•Œé¢ -->
        <div v-if="!hasJoined" class="space-y-6">
            <div class="text-center">
                <h1 class="text-3xl font-bold text-white mb-2">ğŸƒ å¾·å·æ‰‘å…‹</h1>
                <p class="text-green-200">å¤šäººç­¹ç è®¡ç®—å™¨</p>
            </div>

            <div class="bg-white/10 backdrop-blur-sm rounded-2xl p-6 space-y-4">
                <div>
                    <label class="block text-green-200 mb-2 font-medium">ä½ çš„æ˜µç§°</label>
                    <input v-model="playerName" type="text" placeholder="è¾“å…¥æ˜µç§°"
                        class="w-full px-4 py-3 rounded-xl bg-white/20 text-white placeholder-green-300/50 border border-white/20 focus:outline-none focus:border-green-400 text-lg">
                </div>

                <div class="flex gap-3">
                    <button @click="createRoom" :disabled="!playerName || isLoading"
                        class="flex-1 btn-action py-4 bg-gradient-to-r from-yellow-500 to-yellow-600 text-white font-bold rounded-xl text-lg disabled:opacity-50 disabled:cursor-not-allowed">
                        {{ isLoading ? 'åˆ›å»ºä¸­...' : 'åˆ›å»ºæˆ¿é—´' }}
                    </button>
                </div>

                <div class="relative">
                    <div class="absolute inset-0 flex items-center"><div class="w-full border-t border-white/20"></div></div>
                    <div class="relative flex justify-center text-sm"><span class="px-2 bg-green-800 text-green-300">æˆ–</span></div>
                </div>

                <div>
                    <label class="block text-green-200 mb-2 font-medium">æˆ¿é—´å·</label>
                    <input v-model="roomCodeInput" type="text" placeholder="è¾“å…¥6ä½æˆ¿é—´å·"
                        maxlength="6"
                        class="w-full px-4 py-3 rounded-xl bg-white/20 text-white placeholder-green-300/50 border border-white/20 focus:outline-none focus:border-green-400 text-lg text-center tracking-widest">
                </div>

                <button @click="joinRoom" :disabled="!playerName || !roomCodeInput || isLoading"
                    class="w-full btn-action py-4 bg-gradient-to-r from-blue-500 to-blue-600 text-white font-bold rounded-xl text-lg disabled:opacity-50 disabled:cursor-not-allowed">
                    {{ isLoading ? 'åŠ å…¥ä¸­...' : 'åŠ å…¥æˆ¿é—´' }}
                </button>
            </div>
        </div>

        <!-- æ¸¸æˆç•Œé¢ -->
        <div v-else class="space-y-4">
            <!-- é¡¶éƒ¨ä¿¡æ¯æ  -->
            <div class="bg-white/10 backdrop-blur-sm rounded-xl p-3 flex justify-between items-center">
                <div class="text-white">
                    <span class="text-green-300 text-sm">æˆ¿é—´å·:</span>
                    <span class="font-mono font-bold text-lg ml-1">{{ roomCode }}</span>
                </div>
                <div class="flex gap-2">
                    <button @click="copyRoomCode" class="px-3 py-1 bg-white/20 text-white rounded-lg text-sm btn-action">å¤åˆ¶</button>
                    <button @click="leaveRoom" class="px-3 py-1 bg-red-500/50 text-white rounded-lg text-sm btn-action">é€€å‡º</button>
                </div>
            </div>

            <!-- åº•æ± æ˜¾ç¤º -->
            <div class="bg-gradient-to-r from-yellow-600/80 to-yellow-500/80 backdrop-blur-sm rounded-2xl p-4 text-center">
                <div class="text-yellow-100 text-sm mb-1">å½“å‰åº•æ± </div>
                <div class="text-4xl font-bold text-white">{{ formatNumber(totalPot) }}</div>
            </div>

            <!-- åˆ†æ± æ˜¾ç¤º -->
            <div v-if="sidePots.length > 0" class="bg-white/10 backdrop-blur-sm rounded-xl p-3">
                <div class="text-green-300 text-sm mb-2">åˆ†æ±  (Side Pots)</div>
                <div v-for="(pot, idx) in sidePots" :key="pot.id"
                    class="flex justify-between items-center py-2 border-b border-white/10 last:border-0">
                    <div class="text-white text-sm">
                        {{ pot.is_main ? 'ä¸»æ± ' : `åˆ†æ±  ${idx}` }}
                        <span class="text-green-400 text-xs ml-2">({{ pot.player_names?.join(', ') || '-' }})</span>
                    </div>
                    <div class="text-yellow-400 font-bold">{{ formatNumber(pot.total_amount) }}</div>
                </div>
            </div>

            <!-- æ–°ä¸€è½®æŒ‰é’® -->
            <div v-if="totalBet > 0" class="flex gap-2">
                <button @click="startNewRound" class="w-full btn-action py-3 bg-gradient-to-r from-purple-500 to-purple-600 text-white font-bold rounded-xl">
                    ğŸ”„ æ–°ä¸€è½®
                </button>
            </div>

            <!-- ç©å®¶åˆ—è¡¨ -->
            <div class="space-y-2">
                <div v-for="player in players" :key="player.id"
                    :class="['player-card bg-white/10 backdrop-blur-sm rounded-xl p-4', player.is_folded ? 'folded' : '', player.is_all_in ? 'all-in border-2' : 'border border-white/10']">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center gap-2">
                            <span class="text-white font-bold text-lg">{{ player.name }}</span>
                            <span v-if="player.is_folded" class="px-2 py-0.5 bg-gray-500 text-white text-xs rounded">å¼ƒç‰Œ</span>
                            <span v-if="player.is_all_in" class="px-2 py-0.5 bg-yellow-500 text-white text-xs rounded">All-in</span>
                        </div>
                        <div class="text-right">
                            <div class="text-green-400 font-bold text-xl">{{ formatNumber(player.chips) }}</div>
                            <div class="text-green-200 text-xs">ç­¹ç </div>
                        </div>
                    </div>
                    <div class="flex justify-between items-center text-sm">
                        <div class="text-white">
                            æœ¬è½®ä¸‹æ³¨: <span class="text-yellow-400 font-bold">{{ formatNumber(player.bet) }}</span>
                        </div>
                        <div v-if="player.name === playerName && !player.is_folded && !player.is_all_in" class="flex gap-1">
                            <input v-model.number="betAmount" type="number" min="1" :max="player.chips"
                                class="w-20 px-2 py-1 rounded bg-white/20 text-white text-center border border-white/20">
                        </div>
                    </div>
                    <!-- å½“å‰ç©å®¶æ“ä½œæŒ‰é’® -->
                    <div v-if="player.name === playerName && !player.is_folded && !player.is_all_in" class="grid grid-cols-4 gap-2 mt-3">
                        <button @click="doAction('call')" :disabled="totalBet <= player.bet"
                            class="btn-action py-2 bg-blue-500 text-white font-bold rounded-lg text-sm disabled:opacity-50">
                            è·Ÿæ³¨
                        </button>
                        <button @click="doAction('bet')"
                            class="btn-action py-2 bg-green-500 text-white font-bold rounded-lg text-sm">
                            ä¸‹æ³¨
                        </button>
                        <button @click="doAction('raise')"
                            class="btn-action py-2 bg-orange-500 text-white font-bold rounded-lg text-sm">
                            åŠ æ³¨
                        </button>
                        <button @click="doAction('fold')"
                            class="btn-action py-2 bg-red-500 text-white font-bold rounded-lg text-sm">
                            å¼ƒç‰Œ
                        </button>
                    </div>
                    <!-- All-in æŒ‰é’® -->
                    <div v-if="player.name === playerName && !player.is_folded && !player.is_all_in" class="mt-2">
                        <button @click="doAction('all_in')"
                            class="w-full btn-action py-3 bg-gradient-to-r from-yellow-500 to-amber-500 text-white font-bold rounded-lg">
                            All-In ({{ formatNumber(player.chips) }})
                        </button>
                    </div>
                </div>
            </div>

            <!-- æ·»åŠ ç©å®¶æŒ‰é’® -->
            <button v-if="players.length < 9" @click="showAddPlayer = true"
                class="w-full btn-action py-3 bg-white/20 text-white font-bold rounded-xl border-2 border-dashed border-white/30">
                + æ·»åŠ ç©å®¶
            </button>

            <!-- æ·»åŠ ç©å®¶å¼¹çª— -->
            <div v-if="showAddPlayer" class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
                <div class="bg-green-800 rounded-2xl p-6 w-full max-w-sm">
                    <h3 class="text-white font-bold text-xl mb-4">æ·»åŠ ç©å®¶</h3>
                    <input v-model="newPlayerName" type="text" placeholder="è¾“å…¥ç©å®¶æ˜µç§°"
                        class="w-full px-4 py-3 rounded-xl bg-white/20 text-white placeholder-green-300/50 border border-white/20 focus:outline-none mb-4">
                    <div class="flex gap-3">
                        <button @click="showAddPlayer = false; newPlayerName = ''"
                            class="flex-1 py-3 bg-white/20 text-white font-bold rounded-xl">
                            å–æ¶ˆ
                        </button>
                        <button @click="addPlayer" :disabled="!newPlayerName"
                            class="flex-1 py-3 bg-blue-500 text-white font-bold rounded-xl disabled:opacity-50">
                            æ·»åŠ 
                        </button>
                    </div>
                </div>
            </div>

            <!-- é‡ç½®ç­¹ç å¼¹çª— -->
            <button @click="showResetConfirm = true"
                class="w-full btn-action py-3 bg-red-500/30 text-white font-bold rounded-xl border border-red-500/50 mt-4">
                é‡ç½®æ‰€æœ‰ç­¹ç 
            </button>

            <div v-if="showResetConfirm" class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50">
                <div class="bg-green-800 rounded-2xl p-6 w-full max-w-sm">
                    <h3 class="text-white font-bold text-xl mb-4">é‡ç½®ç­¹ç </h3>
                    <p class="text-green-200 mb-4">å°†æ‰€æœ‰ç©å®¶çš„ç­¹ç é‡ç½®ä¸ºåˆå§‹å€¼ï¼Ÿ</p>
                    <div class="flex gap-3">
                        <button @click="showResetConfirm = false"
                            class="flex-1 py-3 bg-white/20 text-white font-bold rounded-xl">
                            å–æ¶ˆ
                        </button>
                        <button @click="resetChips"
                            class="flex-1 py-3 bg-red-500 text-white font-bold rounded-xl">
                            ç¡®è®¤é‡ç½®
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted } = Vue;

        // ===== é…ç½® Supabase =====
        // è¯·åœ¨è¿™é‡Œå¡«å…¥ä½ çš„ Supabase URL å’Œ ANON KEY
        const SUPABASE_URL = 'https://zqvbrmeoixrpczhqwakg.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_8SAt8oqAgoibLgmTFP3LLA_qW-ln5Eu';

        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        createApp({
            setup() {
                // çŠ¶æ€
                const hasJoined = ref(false);
                const playerName = ref('');
                const roomCode = ref('');
                const roomCodeInput = ref('');
                const players = ref([]);
                const sidePots = ref([]);
                const isLoading = ref(false);
                const betAmount = ref(10);
                const showAddPlayer = ref(false);
                const newPlayerName = ref('');
                const showResetConfirm = ref(false);
                const currentRoundBet = ref(0);

                let playersSubscription = null;
                let potsSubscription = null;

                // è®¡ç®—å±æ€§
                const totalPot = computed(() => {
                    return sidePots.value.reduce((sum, pot) => sum + pot.total_amount, 0);
                });

                const totalBet = computed(() => {
                    return players.value.reduce((sum, p) => sum + p.bet, 0);
                });

                const maxBet = computed(() => {
                    return Math.max(...players.value.map(p => p.bet), 0);
                });

                // æ–¹æ³•
                const generateRoomCode = () => {
                    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                    let code = '';
                    for (let i = 0; i < 6; i++) {
                        code += chars.charAt(Math.floor(Math.random() * chars.length));
                    }
                    return code;
                };

                const formatNumber = (num) => {
                    return num?.toLocaleString() || '0';
                };

                const copyRoomCode = async () => {
                    try {
                        await navigator.clipboard.writeText(roomCode.value);
                        alert('æˆ¿é—´å·å·²å¤åˆ¶!');
                    } catch (e) {
                        alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶');
                    }
                };

                const createRoom = async () => {
                    if (!playerName.value.trim()) return;

                    isLoading.value = true;
                    try {
                        const code = generateRoomCode();

                        // åˆ›å»ºæˆ¿é—´
                        const { error: roomError } = await supabase
                            .from('rooms')
                            .insert([{ room_code: code, status: 'active' }]);

                        if (roomError) throw roomError;

                        // æ·»åŠ å½“å‰ç©å®¶
                        const { error: playerError } = await supabase
                            .from('players')
                            .insert([{
                                room_code: code,
                                name: playerName.value.trim(),
                                chips: 1000,
                                bet: 0
                            }]);

                        if (playerError) throw playerError;

                        // åˆ›å»ºä¸»æ± 
                        await supabase
                            .from('pots')
                            .insert([{
                                room_code: code,
                                player_names: [playerName.value.trim()],
                                total_amount: 0,
                                is_main: true
                            }]);

                        roomCode.value = code;
                        hasJoined.value = true;

                        await setupRealtime(code);
                    } catch (error) {
                        console.error('åˆ›å»ºæˆ¿é—´å¤±è´¥:', error);
                        alert('åˆ›å»ºæˆ¿é—´å¤±è´¥ï¼Œè¯·é‡è¯•');
                    } finally {
                        isLoading.value = false;
                    }
                };

                const joinRoom = async () => {
                    if (!playerName.value.trim() || !roomCodeInput.value.trim()) return;

                    isLoading.value = true;
                    try {
                        // æ£€æŸ¥æˆ¿é—´æ˜¯å¦å­˜åœ¨
                        const { data: room, error: roomError } = await supabase
                            .from('rooms')
                            .select('*')
                            .eq('room_code', roomCodeInput.value.trim().toUpperCase())
                            .single();

                        if (roomError || !room) {
                            alert('æˆ¿é—´ä¸å­˜åœ¨');
                            return;
                        }

                        // æ£€æŸ¥æ˜¯å¦å·²åœ¨æˆ¿é—´ä¸­
                        const { data: existingPlayer } = await supabase
                            .from('players')
                            .select('*')
                            .eq('room_code', roomCodeInput.value.trim().toUpperCase())
                            .eq('name', playerName.value.trim())
                            .single();

                        if (existingPlayer) {
                            roomCode.value = roomCodeInput.value.trim().toUpperCase();
                            hasJoined.value = true;
                            await setupRealtime(roomCode.value);
                            return;
                        }

                        // æ·»åŠ ç©å®¶
                        const { error: playerError } = await supabase
                            .from('players')
                            .insert([{
                                room_code: roomCodeInput.value.trim().toUpperCase(),
                                name: playerName.value.trim(),
                                chips: 1000,
                                bet: 0
                            }]);

                        if (playerError) throw playerError;

                        // æ›´æ–°ä¸»æ± çš„å‚ä¸è€…åˆ—è¡¨
                        const { data: mainPot } = await supabase
                            .from('pots')
                            .select('*')
                            .eq('room_code', roomCodeInput.value.trim().toUpperCase())
                            .eq('is_main', true)
                            .single();

                        if (mainPot) {
                            const updatedNames = [...(mainPot.player_names || []), playerName.value.trim()];
                            await supabase
                                .from('pots')
                                .update({ player_names: updatedNames })
                                .eq('id', mainPot.id);
                        }

                        roomCode.value = roomCodeInput.value.trim().toUpperCase();
                        hasJoined.value = true;

                        await setupRealtime(roomCode.value);
                    } catch (error) {
                        console.error('åŠ å…¥æˆ¿é—´å¤±è´¥:', error);
                        alert('åŠ å…¥æˆ¿é—´å¤±è´¥ï¼Œè¯·é‡è¯•');
                    } finally {
                        isLoading.value = false;
                    }
                };

                const setupRealtime = async (code) => {
                    // åŠ è½½åˆå§‹æ•°æ®
                    await loadRoomData(code);

                    // ç›‘å¬ç©å®¶å˜åŒ–
                    playersSubscription = supabase
                        .channel('players-channel')
                        .on('postgres_changes', {
                            event: '*',
                            schema: 'public',
                            table: 'players',
                            filter: `room_code=eq.${code}`
                        }, () => loadRoomData(code))
                        .subscribe();

                    // ç›‘å¬åˆ†æ± å˜åŒ–
                    potsSubscription = supabase
                        .channel('pots-channel')
                        .on('postgres_changes', {
                            event: '*',
                            schema: 'public',
                            table: 'pots',
                            filter: `room_code=eq.${code}`
                        }, () => loadRoomData(code))
                        .subscribe();
                };

                const loadRoomData = async (code) => {
                    const [playersData, potsData] = await Promise.all([
                        supabase.from('players').select('*').eq('room_code', code).order('created_at'),
                        supabase.from('pots').select('*').eq('room_code', code).order('created_at')
                    ]);

                    players.value = playersData.data || [];
                    sidePots.value = potsData.data || [];
                };

                const doAction = async (actionType) => {
                    const player = players.value.find(p => p.name === playerName.value);
                    if (!player || player.is_folded || player.is_all_in) return;

                    const currentMaxBet = Math.max(...players.value.map(p => p.bet), 0);
                    let amount = 0;

                    switch (actionType) {
                        case 'call':
                            amount = currentMaxBet - player.bet;
                            break;
                        case 'bet':
                            amount = Math.min(Math.max(betAmount.value || 10, 1), player.chips);
                            break;
                        case 'raise':
                            amount = Math.min((currentMaxBet - player.bet) + (betAmount.value || 10), player.chips);
                            break;
                        case 'fold':
                            await supabase
                                .from('players')
                                .update({ is_folded: true })
                                .eq('id', player.id);
                            return;
                        case 'all_in':
                            amount = player.chips;
                            break;
                    }

                    if (amount <= 0) return;
                    if (amount > player.chips) amount = player.chips;

                    const isAllIn = amount >= player.chips;

                    // æ›´æ–°ç©å®¶çŠ¶æ€
                    const { error } = await supabase
                        .from('players')
                        .update({
                            chips: player.chips - amount,
                            bet: player.bet + amount,
                            is_all_in: isAllIn
                        })
                        .eq('id', player.id);

                    if (error) {
                        console.error('æ“ä½œå¤±è´¥:', error);
                        alert('æ“ä½œå¤±è´¥');
                        return;
                    }

                    // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºåˆ†æ± 
                    await checkAndCreateSidePots();
                };

                const checkAndCreateSidePots = async () => {
                    const { data: currentPlayers } = await supabase
                        .from('players')
                        .select('*')
                        .eq('room_code', roomCode.value);

                    const activePlayers = currentPlayers.filter(p => !p.is_folded);
                    const allInPlayers = activePlayers.filter(p => p.is_all_in);
                    const notAllInPlayers = activePlayers.filter(p => !p.is_all_in);

                    // å¦‚æœæœ‰ All-in ç©å®¶ï¼Œéœ€è¦åˆ›å»ºåˆ†æ± 
                    if (allInPlayers.length > 0 && notAllInPlayers.length > 0) {
                        // æŒ‰ bet é‡‘é¢æ’åº
                        const sortedByBet = [...activePlayers].sort((a, b) => a.bet - b.bet);

                        for (let i = 0; i < sortedByBet.length - 1; i++) {
                            const currentPlayer = sortedByBet[i];
                            const nextPlayer = sortedByBet[i + 1];

                            if (currentPlayer.is_all_in && currentPlayer.bet < nextPlayer.bet) {
                                // åˆ›å»ºæ–°çš„åˆ†æ± 
                                const excessAmount = nextPlayer.bet - currentPlayer.bet;
                                const eligiblePlayers = sortedByBet
                                    .slice(i + 1)
                                    .map(p => p.name);

                                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç±»ä¼¼çš„åˆ†æ± 
                                const { data: existingPot } = await supabase
                                    .from('pots')
                                    .select('*')
                                    .eq('room_code', roomCode.value)
                                    .eq('is_main', false)
                                    .order('created_at', { ascending: false })
                                    .limit(1)
                                    .single();

                                // è®¡ç®—ä¸»æ± é‡‘é¢ï¼ˆæ‰€æœ‰ç©å®¶éƒ½èƒ½å‚ä¸çš„ï¼‰
                                const mainPotAmount = currentPlayer.bet * (i + 1);

                                // æ›´æ–°ä¸»æ± 
                                const { data: mainPot } = await supabase
                                    .from('pots')
                                    .select('*')
                                    .eq('room_code', roomCode.value)
                                    .eq('is_main', true)
                                    .single();

                                if (mainPot) {
                                    await supabase
                                        .from('pots')
                                        .update({ total_amount: mainPotAmount })
                                        .eq('id', mainPot.id);
                                }

                                // æ›´æ–°æˆ–åˆ›å»ºåˆ†æ± 
                                const sidePotAmount = activePlayers.reduce((sum, p) => {
                                    if (p.bet > currentPlayer.bet) {
                                        return sum + (p.bet - currentPlayer.bet);
                                    }
                                    return sum;
                                }, 0);

                                if (existingPot) {
                                    await supabase
                                        .from('pots')
                                        .update({
                                            total_amount: sidePotAmount,
                                            player_names: eligiblePlayers
                                        })
                                        .eq('id', existingPot.id);
                                } else {
                                    await supabase
                                        .from('pots')
                                        .insert([{
                                            room_code: roomCode.value,
                                            player_names: eligiblePlayers,
                                            total_amount: sidePotAmount,
                                            is_main: false
                                        }]);
                                }

                                break;
                            }
                        }
                    }

                    // æ›´æ–°ä¸»æ± é‡‘é¢ï¼ˆç®€å•æƒ…å†µï¼Œæ—  All-inï¼‰
                    if (allInPlayers.length === 0) {
                        const totalBet = activePlayers.reduce((sum, p) => sum + p.bet, 0);
                        const { data: mainPot } = await supabase
                            .from('pots')
                            .select('*')
                            .eq('room_code', roomCode.value)
                            .eq('is_main', true)
                            .single();

                        if (mainPot) {
                            await supabase
                                .from('pots')
                                .update({ total_amount: totalBet })
                                .eq('id', mainPot.id);
                        }
                    }
                };

                const startNewRound = async () => {
                    const updates = players.value.map(player =>
                        supabase
                            .from('players')
                            .update({ bet: 0, is_folded: false, is_all_in: false })
                            .eq('id', player.id)
                    );

                    await Promise.all(updates);

                    // é‡ç½®ä¸»æ± 
                    const { data: mainPot } = await supabase
                        .from('pots')
                        .select('*')
                        .eq('room_code', roomCode.value)
                        .eq('is_main', true)
                        .single();

                    if (mainPot) {
                        await supabase
                            .from('pots')
                            .update({ total_amount: 0 })
                            .eq('id', mainPot.id);
                    }

                    // åˆ é™¤æ‰€æœ‰åˆ†æ± 
                    await supabase
                        .from('pots')
                        .delete()
                        .eq('room_code', roomCode.value)
                        .eq('is_main', false);
                };

                const addPlayer = async () => {
                    if (!newPlayerName.value.trim()) return;

                    try {
                        const { error } = await supabase
                            .from('players')
                            .insert([{
                                room_code: roomCode.value,
                                name: newPlayerName.value.trim(),
                                chips: 1000,
                                bet: 0
                            }]);

                        if (error) throw error;

                        // æ›´æ–°ä¸»æ± çš„å‚ä¸è€…åˆ—è¡¨
                        const { data: mainPot } = await supabase
                            .from('pots')
                            .select('*')
                            .eq('room_code', roomCode.value)
                            .eq('is_main', true)
                            .single();

                        if (mainPot) {
                            const updatedNames = [...(mainPot.player_names || []), newPlayerName.value.trim()];
                            await supabase
                                .from('pots')
                                .update({ player_names: updatedNames })
                                .eq('id', mainPot.id);
                        }

                        showAddPlayer.value = false;
                        newPlayerName.value = '';
                    } catch (error) {
                        console.error('æ·»åŠ ç©å®¶å¤±è´¥:', error);
                        alert('æ·»åŠ å¤±è´¥ï¼Œå¯èƒ½è¯¥æ˜µç§°å·²å­˜åœ¨');
                    }
                };

                const resetChips = async () => {
                    const updates = players.value.map(player =>
                        supabase
                            .from('players')
                            .update({ chips: 1000, bet: 0, is_folded: false, is_all_in: false })
                            .eq('id', player.id)
                    );

                    await Promise.all(updates);

                    // é‡ç½®ä¸»æ± 
                    const { data: mainPot } = await supabase
                            .from('pots')
                            .select('*')
                            .eq('room_code', roomCode.value)
                            .eq('is_main', true)
                            .single();

                    if (mainPot) {
                        await supabase
                            .from('pots')
                            .update({ total_amount: 0 })
                            .eq('id', mainPot.id);
                    }

                    // åˆ é™¤æ‰€æœ‰åˆ†æ± 
                    await supabase
                        .from('pots')
                        .delete()
                        .eq('room_code', roomCode.value)
                        .eq('is_main', false);

                    showResetConfirm.value = false;
                };

                const leaveRoom = async () => {
                    if (confirm('ç¡®å®šè¦é€€å‡ºæˆ¿é—´å—ï¼Ÿ')) {
                        const player = players.value.find(p => p.name === playerName.value);
                        if (player) {
                            await supabase.from('players').delete().eq('id', player.id);
                        }

                        if (playersSubscription) {
                            playersSubscription.unsubscribe();
                        }
                        if (potsSubscription) {
                            potsSubscription.unsubscribe();
                        }

                        hasJoined.value = false;
                        roomCode.value = '';
                        players.value = [];
                        sidePots.value = [];
                    }
                };

                onUnmounted(() => {
                    if (playersSubscription) playersSubscription.unsubscribe();
                    if (potsSubscription) potsSubscription.unsubscribe();
                });

                return {
                    hasJoined,
                    playerName,
                    roomCode,
                    roomCodeInput,
                    players,
                    sidePots,
                    isLoading,
                    betAmount,
                    showAddPlayer,
                    newPlayerName,
                    showResetConfirm,
                    totalPot,
                    totalBet,
                    maxBet,
                    createRoom,
                    joinRoom,
                    doAction,
                    startNewRound,
                    addPlayer,
                    resetChips,
                    leaveRoom,
                    copyRoomCode,
                    formatNumber
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
